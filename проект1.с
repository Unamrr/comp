сервер
//СЕРВЕР
#define _CRT_SECURE_NO_WARNINGS  // ЭТО РЕШАЕТ ПРОБЛЕМУ С strcpy
#include <iostream>
#include <fstream>
#include <windows.h>
#include <cstring>
using namespace std;

// Структура данных запроса от клиента
struct Student
{
    char name[25];   // имя
    int grade1;    //оценка за первый экзамен и тд
    int grade2;
    int grade3;
    int grade4;
} B; // Переменная для хранения полученных данных, данные запроса от клиента

struct Answer { // структура ответа клиенту
    bool hasDolg; // есть ли задолженность
    int stipendia_size; //размер стипендии
    char message[70]; //сообщение
} C;// будет формировать ответ перед отправкой клиенту

// Исправляем тип переменной для устранения предупреждения
streamoff size_pred;  // Вместо long используем streamoff<-подходит для больших значений

int main()
{
    ifstream fR;     // поток для чтения из файла REQUEST
    ofstream fA;     // поток для записи в файл ANSWER

    setlocale(LC_ALL, "rus");
    SetConsoleOutputCP(1251);  // для русского текста
    SetConsoleCP(1251);

    const char* nameR = "Z:/comp/REQUEST1.bin";   // файл запросов клиентов
    const char* nameA = "Z:/comp/ANSWER1.bin";    // файл ответов сервера

    cout << ".... Деканат сервер работает ...." << endl;

    // *** Начальные установки - определяем текущий размер файла запросов
    fR.open(nameR, ios::binary);            // открытие файла REQUEST
    fR.seekg(0, ios::end);                   // переход в конец файла
    size_pred = fR.tellg();                  // стартовая позиция сервера в файле REQUEST, 
    //tellg возвращает текущую позицию указателя чтения в байтах от начала файла 
    fR.close();                               // закрытие файла

    // *** Начало работы сервера (бесконечный цикл) ***
    while (true)
    {
        // Открытие файла REQUEST для проверки новых запросов
        fR.open(nameR, ios::binary);
        fR.seekg(0, ios::end);                // переход в конец файла

        // Ожидание появления новых запросов
        while (size_pred >= fR.tellg())
        {
            Sleep(100);                        // пауза 100 мс
            fR.seekg(0, ios::end);              // снова переход в конец
        }

        // *** Получен новый запрос ***
        fR.seekg(size_pred, ios::beg);         // переход к началу нового запроса
        fR.read((char*)&B, sizeof(Student));   // считывание данных клиента в структуру B

        size_pred = fR.tellg();                 // обновление позиции
        fR.close();                              // закрытие файла REQUEST

        // Выводим информацию о запросе
        cout << "Студент: " << B.name << endl;
        cout << "Оценки: " << B.grade1 << ", "
            << B.grade2 << ", "
            << B.grade3 << ", "
            << B.grade4 << endl;

        // Проверяем наличие задолженностей (оценки 2 и ниже)
        bool hasDolg = (B.grade1 <= 2 ||
            B.grade2 <= 2 ||
            B.grade3 <= 2 ||
            B.grade4 <= 2);

        // Рассчитываем средний балл
        double average = (B.grade1 +
            B.grade2 +
            B.grade3 +
            B.grade4) / 4.0;

        // Формируем ответ
        C.hasDolg = hasDolg;
        if (hasDolg) {
            // Есть задолженности
            C.stipendia_size = 0;
            // Используем strcpy - работает благодаря #define
            strcpy(C.message, "Есть задолженности. Стипендия не назначается.");
            cout << "Результат: Есть задолженности" << endl;
        }
        else {
            // Нет задолженностей - рассчитываем стипендию
            if (average >= 4.5) {
                C.stipendia_size = 5555;
                strcpy(C.message, "Повышенная стипендия 5555 руб.");
                cout << "Результат: Повышенная стипендия (ср.балл " << average << ")" << endl;
            }
            else if (average >= 4.0) {
                C.stipendia_size = 2250;
                strcpy(C.message, "Обычная стипендия 2250 руб.");
                cout << "Результат: Обычная стипендия (ср.балл " << average << ")" << endl;
            }
            else {
                C.stipendia_size = 0;
                strcpy(C.message, "Нет задолженностей, но стипендия не положена (ср.балл < 4.0)");
                cout << "Результат: Нет стипендии (ср.балл " << average << ")" << endl;
            }
        }

        // *** Передача ответа клиенту ***
        fA.open(nameA, ios::binary | ios::app);//запись будет производиьс в конец файла
        fA.write((char*)&C, sizeof(Answer));//запись структуры ответа в файл
        fA.close();

    } // while

    return 0;
}

//ПРОГРАММА КЛИЕНТ
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <fstream>
#include <windows.h>
using namespace std;

// структура данных запроса клиента (СТУДЕНТ)
struct Student
{
    char name[25]; // фамилия
    int grade1;    // оценка 1
    int grade2;    // оценка 2
    int grade3;    // оценка 3
    int grade4;    // оценка 4
} A;//контейнер куда вводят данные структуры с клавы перед отправкой серверу

// структура для ответа от сервера
struct Answer {
    bool hasDolg;         // есть ли задолженность
    int stipendia_size;   // размер стипендии
    char message[70];     // сообщение
} D;//контейнер где клиент читает ответ сервера 

void main() {
    setlocale(LC_ALL, "rus");

    const char* nameR = "Z:/comp/REQUEST1.bin";//Файл для запросов клиентов
    const char* nameA = "Z:/comp/ANSWER1.bin"; //Файл для ответов сервера
    ofstream f_REQ;//для записи
    ifstream f_ANS;//для чтения
    long pred_size;//переменная закладка

    while (true)
    {
        // передача данных от клиента серверу
        cout << "Введите данные студента: Фамилия и 4 оценки" << endl;
        cout << "Фамилия: ";
        cin >> A.name;
        cout << "Оценка 1: ";
        cin >> A.grade1;
        cout << "Оценка 2: ";
        cin >> A.grade2;
        cout << "Оценка 3: ";
        cin >> A.grade3;
        cout << "Оценка 4: ";
        cin >> A.grade4;

        // контрольный вывод
        cout << "\nОтправляется: " << A.name << " "
            << A.grade1 << " " << A.grade2 << " "
            << A.grade3 << " " << A.grade4 << endl;

        f_REQ.open(nameR, ios::app | ios::binary);//открытие файла REQUEST все автоматически добавится в конец файла
        f_REQ.write((char*)&A, sizeof(Student));//запись запроса в файл REQUEST данные из А копируются в файл
        f_REQ.close();//закрываем фйл чтобы сервер смог открыть и прочитать
        cout << "Запрос отправлен, жду ответ..." << endl;

        // поступил ответ от сервера?  //открытие файла ANSWER
        f_ANS.seekg(0, ios::end);  //переход в конец файла ANSWER
        pred_size = f_ANS.tellg(); // смотрит размер и запоминает его
        f_ANS.close();

        // ждем пока размер файла не увеличится (появится новый ответ)
        while (true) {
            Sleep(100);
            f_ANS.open(nameA, ios::binary);
            f_ANS.seekg(0, ios::end);
            long current_size = f_ANS.tellg();
            f_ANS.close();
            if (current_size > pred_size) break;//как только размер больше фай закрывается
        }

        // получение ответа от сервера
        f_ANS.open(nameA, ios::binary);
        f_ANS.seekg(pred_size, ios::beg);// перемещаем указатель на начало нового ответа
        f_ANS.read((char*)&D, sizeof(Answer)); // считывание ответа
        f_ANS.close();

        // расшифровка ответа
        cout << "\n=== РЕЗУЛЬТАТ ===" << endl;
        cout << D.message << endl;
        if (D.stipendia_size > 0) {
            cout << "Размер стипендии: " << D.stipendia_size << " руб." << endl;
        }
        cout << endl;

    } //while
}
**************************************************************************




//сервер
#include <iostream>
#include <fstream>
#include <windows.h>
using namespace std;
struct Person
{
	char name[25];	 //имя 
	int height;		//рост
	int weight;		//вес
}B;
int answer;
long size_pred;
int main() {
	ifstream fR;
	ofstream fA;
	setlocale(LC_ALL, "rus");
	const char* nameR = "Z:/comp/REQUEST.bin";
	//файл запросов клиентов
	const char* nameA = "Z:/comp/ANSWER.bin";
	//файл ответов сервера
	cout << "server is working" << endl;
	// начальные установки
	fR.open(nameR, ios::binary);
	//открытие файла REQUEST
	fR.seekg(0, ios::end);
	size_pred = fR.tellg();
	//стартовая позиция сервера в файле REQUEST
	fR.close();

	// начало работы сервера
	while (true)
	{
		fR.open(nameR, ios::binary);
		//открытие файла REQUEST
		fR.seekg(0, ios::end);
		//переход в конец файла REQUEST
		// есть новые запросы от клиентов? 
		while (size_pred >= fR.tellg())
		{
			Sleep(100); fR.seekg(0, ios::end);
		}
		// получен новый запрос 
		fR.seekg(size_pred, ios::beg);
		//переход к началу полученного запроса
		fR.read((char*)&B, sizeof(B));
		//считывание данных клиента
		size_pred = fR.tellg();
		// на конец обработанных данных
		fR.close();
		// определение индекса массы	
		double IMT = B.weight / (0.01 * B.height) / (0.01 * B.height);
		if (18.5 <= IMT && IMT < 25) answer = 1;
		if (18.5 > IMT) answer = 0;
		if (IMT >= 25)answer = 2;

		// передача ответа клиенту
		fA.open(nameA, ios::binary | ios::app);
		//открытие файла ANSWER
		fA.write((char*)&answer, sizeof(answer));
		//запись ответа клиенту
		fA.close();
	}// while
}

//клиент
#include <iostream>
#include <fstream>
#include <windows.h>
using namespace std;
// структура данных запроса клиента
struct Person
{
	char name[25];  //имя
	int height;		//рост
	int weight;		//вес
} A;
void main() {
	setlocale(LC_ALL, "rus");

	const char* nameR = "Z:/comp/REQUEST.bin";
	//файл для запросов клиентов
	const char* nameA = "Z:/comp/ANSWER.bin";
	//файл для ответов сервера
	ofstream f_REQ;
	ifstream f_ANS;
	long pred_size;
	int answer;
	while (true)
	{
		// передача данных от клиента серверу
		cout << "Введите запрос: Фамилия Рост Вес" << endl;
		cin >> A.name >> A.height >> A.weight;
		cout << A.name << A.height << A.weight;
		f_REQ.open(nameR, ios::app | ios::binary);
		//открытие файла REQUEST 
		f_REQ.write((char*)&A, sizeof(A));
		//запись запроса в файл REQUEST
		f_REQ.close();

		// поступил ответ от сервера?
		f_ANS.open(nameA, ios::binary);
		//открытие файла ANSWER
		f_ANS.seekg(0, ios::end);
		//переход в конец файла ANSWER
		pred_size = f_ANS.tellg();
		while (pred_size >= f_ANS.tellg())
		{
			Sleep(100);
			// ждем и переходим в конец файла ANSWER
			f_ANS.seekg(0, ios::end);
		}
		// получение ответа от сервера	
		f_ANS.seekg(pred_size, ios::beg);
		// на начало нового ответа
		f_ANS.read((char*)&answer, sizeof(answer));//считывание ответа
		f_ANS.close();

		// расшифровка ответа
		switch (answer) {
		case 0: { cout << "Недостаток веса\n"; break; }
		case 1: { cout << "Норма веса\n"; break; }
		case 2: { cout << "Избыток веса\n"; break; }
		}
	} //while
}

